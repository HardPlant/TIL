# 181125

티오리

* 프로토타입(1~2개월) - 마켓

* 

## 브라우저 익스플로잇

* POC 16 

IE -> Sandbox -> Windows Kernel

* CFG - control flow

(함수 포인터 변조 우회)

화이트리스트 검증임
->ROP(스택을 검증하지는 않음)
->RFG(캔슬됨, 코스트 문제)


* ACG - Arbitrary Code

mmap(), mprotect()
r/w 페이지를 막음

rop 2017년 논문 / rtl

turing complete한 코드를 만들 수 있음

* pwn.js - ROP 인터페이스

##### 같은 HTML/JS 스펙

완전히 다른 구조

* 메모리 할당

* 옵티마이저

* 보안 모델, 미티게이션

### 크롬

* 운영체제/컴파일러 컨트롤 불가

* 2013년부터 Blink 엔진을 씀

* Release Channel : 

OmahaProxy - 운영체제별 버전 볼수 있음

##### 크롬 보안 모델

* Webapp security

* Sandbox

* Memory allocators

##### Sandbox

Broker: {Policy - Interception Manager}
Sandbox..  ㄴ IPC {Policy Engine Client - Interceptions(후킹 -> 네트워크 커넥션/FS 업로드 메시지를 브로커에 전달)..}
    IPC
    IPC

* Policy Engine Client

보안적으로는 의미가 없음, 브로커가 할 일을 줄여줌(IPC Bandwidth 관리, Broker 단에서 막는)

##### 제한

* Token, Job object

* Isolated desktop

다른 프로세스와 다른 보안 컨텍스트 강제

* Integrity level

Medium, Low, Untrusted(plugins)
서로 간 통신은 IPC임

* Mitigation policies

타겟 프로세스에 

* Sandbox -> 커널을 바로 공격함

* Win32k (driver, 90) 의존성 제거(8.1부터)

context switch -> 그래픽적인 게 많으면 자주 일어남
그래픽 코드를 커널로 땡김

* Site Isolation

CORS, SOP


세션 가져오는 사람들이 찾음, 샌드박스 탈출도 필요 없음

탭마다 다른 프로세스인데, iframe으로 실행 시 같은 프로세스가 됬었음

같은 탭, 다른 iframe(도메인)이 다른 프로세스에서 돌게 함

UXSS를 약화시킴 (크로스사이트 데이터 훔치기 불가)

다른 프로세스에서 렌더링하는 문제가 있음, 고치는데 몇 년이 걸림

* 메모리 커럽션

...

### Memory Allocator

* Oilpan, PartitionAlloc, Discardable Memory, malloc

* 퍼포먼스

heap 익스 어렵게 함

* JS 엔진부터

##### Oilpan

GC

ref count를 대체함 (UAF 방지, dangling pointer 못 씀)

싱글스레드 mark-and-sweep함

각 쓰레드별로 힙을 줌, 힙의 arena 객체를 또 구분시킴

free되면 메모리 0으로 채움

##### PartitionAlloc

기본 memory allocator임

메모리 커럽션을 막음

힙의 파티션을 나눠서 lifetime을 부여함
파티션 사이에 가드페이지를 넣어 덮어쓰기 방지

주소가 다른 파티션용으로 절대 사용하지 않음 (운영체제에 돌려주지 않음)

메모리 메타데이터를 다른 곳에 보관함, 빅엔디안으로 주소 처리해서 1byte 변경 시에도 MSB가 바뀌게 됨 (LSB보다 할 수 있는게 적어짐)

##### malloc

##### Secure autoupdate

* SSL Signed됨, 구글 업데이터에서 복호화

* 버전넘버 트래킹함, downgrade 안됨

* 1~2주마다 업데이트됨, 오프셋이 변경됨

### V8

ECMA, JIT, WebAssembly

* 인터프리터 (실행빈도 낮은 것들) - Ignition

* 사이트에서 계속 실행되는 코드 - 컴파일 (Turbopan)

##### JS Object

* SMI (Small integers)

* HeapObjects

##### Memory(Heap)

* 따로 존재하는 memmory allocator

* ArrayBuffer - 버퍼를 C처럼 할당하는 인터페이스

##### SMI

tagged pointer와 integer를 차별화함

32bit에서 31bit, 64bit에서 32bit만 쓰고 나머지는 0으로 패딩함 (최종값은 반드시 0)

##### HeapObject

pointer를 LSB에서 체크함(마지막bit nonzero)

31bit보다 큰 수 (HeapNumber) boxing함

map을 만들어서 reflective한 정보를 저장함

* 크기

* 인스턴스 속성, 타입 정보

* GC 이터레이션 정보

가짜 오브젝트를 만들 때 HeapObject포맷을 맞춰줘야 함

HeapObject{int,pointer,[\],taggedobject[\]}

##### Double-array unboxing

ElementsKind에서 성능최적화를 위해 추적됨

* Packed/Holey
* SMI/DOUBLE/object

* PACKED_DOUBLE_ELEMENTS

배열 안의 모든 요소가 double이면 unboxed, SMI들도 double로 바꿈 (C의 double[])

### Heap

[New | Old* | OldData | LargeObj | Code....]

##### New space

* Scavenge : Cheney's algorithm

방 2개를 두고, alloc list를 tospace로 copy하면서(memcpy) 주소를 바꾼 후 원래 방(fromspace)를 버림

##### ArrayBufferContnents

ArrayBuffer를 가지고 익스플로잇 초기점을 찾음

PartitionAlloc으로 Backing store을 할당함
JSArrayBuffer는 V8 Heap에 할당되고, 스토어를 향한 포인터를 가짐

##### PartitionAlloc Re-visited

* SuperPage(2MB) - 2MB로 할당
\[GuardPage|MetadataPage|GuardPages\[2]|Slot span.... | Guard pages\[4]]

Metadata Page(4kb) -> \[SuperPageExtentEntry(32b),PartitionPage(32b).....] : 127 partitionPages, 마지막은 guard page임

* SuperPageExtentEntry(32B)-> \[root, superPageBase, superPageEnd, next]
ArrayBuffer 파티션은 global array buffer allocator를 알 수 있음, 그것으로 힙 주소를 알아낼 수 있음

* Slot span(최대 64KB, 4 PartitionPage)

* PartitionPage (in Slot span)

\[freelistHead, nextPage, bucket, {numAllocate,...,}]

freelistHead는 PartitionPage의 free list 헤드를 가리킴

### Arbitrary R/W Primitive

버그 클래스에 따라 다름

* 주요 종류

ArrayBuffer OOB : 얻을 수 있는 메모리가 PartitionAlloc 힙에 존재함

JS Object OOB : 오브젝트 메모리를 쉽게 leak 가능함

아직 partial primitive임




