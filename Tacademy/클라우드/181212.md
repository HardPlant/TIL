# Netflix OSS, Spring Cloud 를 활용한 MSA 구축 및 개발

[](https://github.com/Gunju-Ko/spring-cloud-workshop)

* 빌드 배포 시스템

* 프로젝트에 CI/CD 적용

### 예전 배포 (without aws)

scp / tomcat-manager(메모리 문제 있음)
클린 배포(down/deploy/up)
dns 설정..

* 무중단 배포 불가능

##### HA 구성 (High-Availability)

로드밸런서, 여러 대 톰캣

LB out ()-> tomcat down -> deliver -> tomcat up -> LB in

LB - L4 switch, L7 (HAProxy)

##### 동접 1000명 이상

LB
배포 방식 변경 : Jenkins, Ansible, Chef

##### 조직 분리

단일 Repo

* Merge시 Conflict

* QA

* 팀마다 다른 일정, 배포 이슈

push 전담 인력/배포 전담 인력이 생김

* 팀별 도메인 분리, Repo 분리

그래도 공통 부분을 담는 Share.jar 레포지토리가 있어야 함

정기배포시 각 프로젝트에서 compile `'kr.co.12st:share:1.0.0-SNAPSHOT'`

(SNAPSHOT 버전이 붙어 있으면 mvn에서 라이브러리 다시 다운받음)

여전히 정기배포 필요 (share.jar)

* 소스코드가 수백만 줄이 되면 윈도우에서 로드하기 힘들어짐

* 코드가 어디서 쓰이는지 알 수 없음.. copy&paste

usage만으로는 부족함, 리플렉션 호출은 못 잡음

### 콘웨이의 법칙

(광범위)

### 모놀리틱 아키텍쳐

* 개발 단순

* 배포 단순

* Scale-out 단순

.. DB가 1개이므로 한계가 있음
한계가 오면 MSA로 넘어감

##### 단점

* 무거움

* App 시작이 오래 걸림

* 책임 한계, 소유권 불투명해짐

개발자 만족도가 떨어짐

### 회사의 결정

* 빅뱅 / 차세대 프로젝트(은행권)

NetScape가 이러다 망함

* MSA 플랫폼을 구축하며 고사시킴

### MSA

아마존/넷플릭스
제프 베조스가 아버지나 다름 없음 (2002년 메일)
잡스를 뛰어넘는 마이크로매니징의 1인자라고 함

AWS 릴리즈 (2006년), 내부 플랫폼과 똑같음

##### 넷플릭스

2008년에 SPoF 발생
2009년에 AWS 이관함, 확장성/성능/가용성

* On-premise에 비해 18배 비용 감소시킴

##### 공식적인 정의

없음

* 공감대

3~9명 이상의 팀일 때 쪼개기 가능
9명이 12개 MSA를 만들면...
(클라우드 네이티브 없이) -> 문제 파악이 안됨, 장애 증가

아직은 아이디어 수준임

##### Mono / MSA 비교

share.jar 제거 (MSA는 코드 공유를 하지 않음)
DB도 공유하지 않음 (팀별 독립 db)

서비스에서 rest 호출

DB는 가장 분리하기 힘든 부분임
큰 데이터베이스를 MSA 데이터베이스로 어떻게 분리할 것인가?
(MSA의 꽃임)

DB 분리는 분산 트랜잭션, 이벤트주도도 가야함

* 쿠팡 케이스 ... 아마존과 비슷한 방법론

다른 팀의 DB에 접근하면 안됨
replica로 DB를 생성하든지

* 이벤트 드리븐(linkedin 방식)
captureDirChange / DB에 저장된 트랜잭션 기록을 모두 읽어 Kafka에 쏨
받은 이벤트를 하나하나 분리함

* MSA는 코드 중복을 허용함, API 스펙이 견고하게 됨

매주 API에 대한 변경 여부 등 커뮤니티를 만들어야 함

### 실습

* Display(전시 영역, 8081) -> 상품 호출(8082)

```
request : /displays/{diplayId}
response : "[product id = " + productId + " at " + System.currentTimeMillis() + "]";
```

### Cloud Native

위치는 중요하지 않음
애플리케이션은 어떻게 만들고 배포하는가?

### DevOps

* 전통적 모델

개발/운영 분리
일을 던지고 잊어버림 (UDP)

* DevOps

"You run it, you build it" 만들면 운영까지 해야 함

팀이 프로젝트 그룹 아닌 제품 그룹에 소속

##### Twelve Factors

Heroku 클라우드 플랫폼 창시자들이 만듬
지키면 MSA하기 편해짐
프로젝트 진행 시 프로젝트 구조, 배포 구조를 잡을 때 참고하면 편함

* 핵심 사상

선언적 - 무엇을 해야 한다 (명령적, 어떻게 해야 하는지가 아님)
이식성 - OS에 구애받지 않도록
클라우드 플랫폼 기반 개발
지속적 배포
수직적 확장

* 

* 

* 

* 

* 백엔드(지원) 서비스

backing 서비스는 필요에 따라 추가되는 자원
환경마다 바꿀 수 있도록

* 빌드, 릴리즈, 실행

빌드/실행을 분리해야 함
빌드 -> Jenkins, 하나의 패키지를 만듬
릴리즈 -> 빌드에 환경설정 정보 **조합**, 젠킨스 아티팩트, 시맨틱 버저닝(Netflix nebular)등 식별자
실행 -> 릴리즈 버전 중 하나를 실행

* 포트 바인딩

포트에 연결해 외부에 공개
11st에서도 임베디드 톰캣을 쓰고 있음
실행 환경에 웹 서버를 따로 추가해줄 필요 없음

* 동시성
(Histrix)

App이 필요할 때마다 Process/Thread 만들어 병렬적으로

HTTP 요청 - 서블릿 쓰레드가 처리
시간이 오래 걸리는 작업은 워커 쓰레드가 처리

(톰캣 기본설정 : 서블릿 쓰레드 - 200개)

* 차분성

graceful하게 shutdown되야 함

사용하는 리소스가 정리되는가

* dev/prod 일치

최대한 비슷하게
3가지 차이
* 시간
* 개인
* 도구 

L4 : 보통 상용에서만 씀, 테스트가 될 수 없음
개발 L4를 붙여도 상용과 동일하게 하기 쉽지 않음

* 

* 로그

애플리케이션은 로그 파일 저장에 관여하지 않아야 함
로그를 중앙에 저장

* Admin 프로세스

admin 코드도 app 코드와 함께 git에 있어야 함

* **제약사항임**

하나하나 지키면 좋음

### REST API

행위에 집중


