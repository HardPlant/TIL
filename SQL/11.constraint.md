# 제약조건, 뷰, 트랜잭션

새 사람을 여러 테이블에 넣어 보자.

```sql (EXPECTED)
INSERT INTO my_contacts (first_name, last_name, zip_code)
VALUES ('Pat', 'Murphy', 'patmurphy@someemail.com', '10087');

INSERT INTO profession VALUES ('teacher')
WHERE prof_id = (SELECT prof_id FROM my_contacts WHERE first_name= 'Pat' AND last_name = 'Murphy');

INSERT INTO status VALUES ('married')
WHERE status_id = (SELECT status_id FROM my_contacts WHERE first_name= 'Pat' AND last_name = 'Murphy');
```

```sql (REAL)
INSERT INTO my_contacts VALUES ('','Pat', 'Murphy','patmurphy@someemail.com','X',1978-04-15,
(SELECT prof_id FROM profession WHERE profession = 'teacher'),
'10087',
(SELECT status_id FROM status WHERE status = 'married') );
```

## CHECK 제약조건

`NOT NULL, PRIMARY KEY, FOREIGN KEY, UNIQUE` 등이 제약조건이다.

```SQL
ALTER TABLE my_contacts
ADD CONSTRAINT CHECK gender IN ('M', 'F');
```

## 뷰 제약조건

자주 사용하는 SELECT문 등을 데이터베이스 내에 저장할 수 있다.

```sql
CREATE VIEW web_designers AS
select mc.first_name, mc.last_name, mc.phone, mc.email
FROM my_contacts mc NATURAL JOIN job_desired jd
WHERE jd.title = 'Web Designer';
```

### 뷰 보기

`SELECT * FROM web_designers`

실제로는 서브 쿼리처럼 동작하고, FROM 절에는 테이블이 나와야 하며 별명이 필요하기 때문에 서브 쿼리에 AS를 붙인 형태로 동작한다.

뷰는 사용할 때 생성되고 나중에 지워진다. 하지만 데이터베이스의 구조를 변경해도 테이블에 의존하는 어플리케이션을 변경할 필요가 없다.
복잡한 조인, 서브 쿼리를 반복해서 사용할 필요가 없고, 사용자에게 필요없는 정보를 숨기는 뷰를 만들 수 있다.

```sql
CREATE VIEW job_raises AS
SELECT mc.first_name, mc.last_name,
    (jd.salary_low - jc.salary) AS raise
FROM job_current jc NATURAL JOIN job_desire jd
    NATURAL JOIN my_contact mc;
```

