# 요구사항 분석
    나누는 기준은 시간임

## 정적 분석 (Use Case)
    유스케이스를 사용해 요구사항을 사용하는 주체와 행위로 나누는 과정
    시간 개념은 배제해야 함
    유스케이스에 시간 개념을 넣으면 개발 행위가 아닌 사용자 행위를 유스케이스로 만들게 됨
        ex) 전원 On-> 개발해야 하는 기능이 아니라 사용자의 행위임
            시스템 이상 여부 검사로 만들고 전원 On은 동적 분석 단계로 넘겨야 함
    
* 유스케이스 도출
    액터를 먼저 추가하고 유스케이스를 그리는 대신, 
    이전 결과물로부터 현 단계에 필요한 요소를 먼저 유스케이스로 도출

    - 실행되는 파일 감시
    - 차단할 파일 정보를 네트워크로 받기
    - 파일을 구분할 수 있는 정보 생성
    - 차단할 파일 정보를 네트워크로 보내기
    - 악성 파일들을 한 디렉터리에서 관리
    
* 액터 도출
    유스케이스 다이어그램을 그리기 시작할 때 액터를 추가
    - 액터는 사용자 또는 시스템 (실체가 분명해야 함)
    - UML 실용 설계에서는 액터와 유스케이스 관계의 개수가
        이후 동적 분석에서 그릴 액티비티 개수와 둥일, 이후 동적/ 정적 설계에 영향
    - 따라서 최소한의 액터만 작성하되 모든 유스케이스와 연관 있게 추가해야 함

    - 액터를 추가하는 방법
        > 1. 인터뷰를 통해 알게 된 [시스템 사용자]를 액터로 추가
        > 2. 시스템 사용자 액터가 사용할 수 있는 모든 유스케이스를 연결
        > 3. 남은 유스케이스를 사용할 수 있는 액터 추가
        > 4. 2번부터 반복함
    
* 유스케이스 관계 맺기
    1. 전산 관리자 : 액터
    2. 관리자가 악성 파일 관리 : use 관계
    3. 관리-> 변경된 파일 정보 보내기 : invoke
    4. 남아 있는 유스케이스들은 IoT 장치가 사용 : 액터
    5. IoT 장치는 파일을 감시
    6. 변경된 악성 파일 정보를 받아야 함
    7. 파일을 감시할 때는 정보를 사용해야 하므로 Dependency
    8. 파일을 보내기, 받기에도 Dependency
    9. 개발 경험이 없는 유스케이스는 회색으로 표시

* 해보지 않은 것들을 회색으로 색칠 후, 필요한 지식 도출
    * 실행되는 파일을 감시하는 방법?
    * 파일을 구분하는 정보는 어떻게 얻나?
    * 제약사항에서 프로세스를 줄이라는 데, socket 관련 프로세스는 어떻게 줄일 것인가?

## 동적 분석 (Activity)
    액티비티는 행위의 순서를 명시함
    정적 분석 -> 액터, 유스케이스 도출
    유스케이스 시간 흐름으로 분석-> 공통의 Action 도출
    이것이 정적 설계(Class)의 토대가 됨

    - 이전 단계에서 알게 된 것들을 토대로 개발에 더 가깝게 표현

* 액티비티 도출
    - 프로세스 필터링
        커널을 수정해 실행되는 프로세스를 필터링
        '필터링 드라이버'라고 함

    - 파일에서 해시 추출
        파일을 구분할 수 있는 정보 생성
        해시 값 이용

    - 커널 소켓으로 해시 목록 수신
        파일 정보를 주기적으로 받아야 함
        일반적으로 데몬 프로세스를 만들어야 하나, 제약사항 때문에 프로세스 만들기 불가능
        커널에서 소켓 통신 (프로토타입 실험 필요)

    - 소켓으로 해시 목록 전송
        관리자가 악성 프로그램을 가지고 있다고 했음
        관리하는 쪽에서는 일반적인 소켓으로 해시 목록 전송

    - 악성 파일 추가/삭제 감지
        관리자는 한 디렉터리에서 악성 파일 관리
        악성 파일이 추가되므로, 자동으로 감지하면 편리

* 액티비티 다이어그램 작성
    - Actor의 Use 관계가 액티비티의 Initial이 됨

    - 전산 관리자가 악성 파일을 관리하는 것으로 시작
    - 첫 번째 Initial - IoT 관리 서버 부팅
    - IoT 장치도 마찬가지로 부팅되어야 프로세스 필터링, 해시 목록 수신 가능
    - 개발 가능한 플로우로 이어주면 됨

    - 악성 파일이 업데이트되면 악성 파일 목록을 추출해
        해당 파일에서 Hash 추출 필요

    - 공통되는 액션이 생김 (파일에서 Hash 추출)
        * 하나의 액티비티를 두 개의 시작점이 공유
        * 여러 Node 또는 Component에서 공통으로 사용하는 코드 부분 찾기 가능
        * 동적 분석에서 찾은 공통부분은 정적 설계(Class)의 공통 함수로 만들어짐
        * 이것들이 컴포넌트로 모이면 라이브러리로 만들 수 있음
        * 개발자의 감이 아닌 요구사항에 근거한 공통부분 설계하면 
            공통 코드의 참조 카운트가 2 이상이 됨
        * 소스 코드에 중복이 없게 됨
            - 개발 일정 단축
            - 코드의 전체 양 줄어듬
                * 버그의 수도 줌
                * 코드 수정에 따른 영향도도 낮게 됨
    - 플로우 내용
        1. 부팅되면 동시에 두 가지 시작 (스레드)

        * IoT 관리 서버
            2. 악성 파일 추가/삭제 감시 시작
            3. 감시 시작과 동시에 디렉터리에서 파일 목록 추출
            4. 악성 파일이 이후에도 추가되거나 삭제되면 다시 파일 목록 추출
            5. 파일 목록의 파일들에서 해시 목록 추출
            6. 추출한 해시 목록을 IoT 장치로 전송함
        * IoT 장치
            2. 서버로부터 차단할 파일의 해시 목록을 커널 소켓으로 수신
            3. 동시에 프로세스 필터링 시작
            4. 실행되는 프로세스 파일에서 해시 정보 추출
            5. 추출된 해시 정보와 일치하는 해시가 수신된 목록에 있는지 검사
            6. 일치 시 프로세스 실행 차단 (악성)
            7. 일치하지 않을 시 실행 허용 (정상)

    - 프로토타입으로 할 내용
        * 프로세스 실행 감시 드라이버
        * 커널 소켓 프로그래밍
        * 한 디렉터리 내 파일의 변화 감지
        * 파일에서 해시 값 추출 방법

    - 공통으로 만들어야 할 부분
        * 파일에서 해시 추출