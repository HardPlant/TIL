# 개발자를 위한 Chaincode

체인코드는 장부 업데이트나 쿼리에 의해 실행될 수 있다. 적절한 구너한 이있으면 체인코드는 다른 체인코드를 부를 수 있다. (현재 채널이나 다른 채널에 있는) 그리고 그 상태에 접근할 수 있다.
만약 호출된 체인코드가 다른 채널에 있다면, 읽기만이 허용된다

## Chaincode API

모든 체인코드 프로그램은 `Chaincode` interface를 구현해야 한다.

이 메서드는 받은 트랜잭션에 응답한다.
`Init` 메서드는 `instantiate`나 `upgrade` 트랜잭션을 받으면 호출되어, 애플리케이션 상태 초기화를 포함한 필요한 초기화를 한다
`Invoke` 메서드는 `invoke` 트랜잭션에 응답해, 트랜잭션 제안을 처리한다.

체인코드 `shim`의 다른 API는 `ChaincodeStubInterface`이다.

이 API는 장부에 접근하고 수정할 때 사용되며, 체인코드 간 호출에 사용된다.

이 튜토리얼에서 우리는 이 API를 사용해 간단한 자산을 관리하는 체인코드 app을 만든다.

## Simple Asset Chaincode

간단한 키-값 자산을 장부에 생성하는 샘플 체인코드이다.

### 코드 위치 정하기

홈 디렉터리(또는 $GOPATh/src)에 sacc 폴더를 만들고 sacc.go 파일을 만들자.

## Housekeeping

모든 체인코드는 Chaincode Interface를 구현한다.
go `import`문으로 필요한 의존성을 추가하자. 우리는 chaincode shim 패키지와 peer protobuf 패키지를 임포트하고, SimpleAsset 구조체를 Chaincode shim 함수의 receiver로 만들 것이다.

```go
package main

import (
    "fmt"

    "github.com/hyperledger/fabric/core/chaincode/shim"
    "github.com/hyperledger/fabric/protos/peer"
)

// SimpleAsset implements a simple chaincode to manage an asset
type SimpleAsset struct {
}
```

## 체인코드 초기화

`Init` 함수를 구현한다.

```go
// Init is called during chaincode instantiation to initialize any data.
func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response {

}
```

(체인코드 업그레이드도 이 함수를 부른다. 체인코드가 이미 존재하는 것을 업그레이드한다면, `Init` 함수를 적절히 바꿔야 한다. 특별히, 업그레이드에 아무 것도 초기화하지 않거나 마이그레이션이 없다면 빈 Init 메서드를 만든다.)

다음으로, Init 함수의 매개변수로 `ChaincodeStubInterface.GetStringArgs` 함수를 부르고 유효성을 검증한다. 우리는 키-값 쌍을 예상하고 있다.

```go
// Init is called during chaincode instantiation to initialize any
// data. Note that chaincode upgrade also calls this function to reset
// or to migrate data, so be careful to avoid a scenario where you
// inadvertently clobber your ledger's data!
func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response {
  // Get the args from the transaction proposal
  args := stub.GetStringArgs()
  if len(args) != 2 {
    return shim.Error("Incorrect arguments. Expecting a key and a value")
  }
}
```

다음으로 이 호출이 유효함을 확인했으니, 장부의 초기 상태를 저장한다. 우리는 `ChaincodeStubInterface.PutState`에 전달받은 키-값을 넣어 호출한다. 성공하면 `peer.Response`가 성공을 알린다.

```go
// Init is called during chaincode instantiation to initialize any
// data. Note that chaincode upgrade also calls this function to reset
// or to migrate data, so be careful to avoid a scenario where you
// inadvertently clobber your ledger's data!
func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response {
  // Get the args from the transaction proposal
  args := stub.GetStringArgs()
  if len(args) != 2 {
    return shim.Error("Incorrect arguments. Expecting a key and a value")
  }

  // Set up any variables or assets here by calling stub.PutState()

  // We store the key and the value on the ledger
  err := stub.PutState(args[0], []byte(args[1]))
  if err != nil {
    return shim.Error(fmt.Sprintf("Failed to create asset: %s", args[0]))
  }
  return shim.Success(nil)
}
```

## 체인코드 호출

Invoke 함수의 시그니처를 추가해보자.

```go
// Invoke is called per transaction on the chaincode. Each transaction is
// either a 'get' or a 'set' on the asset created by Init function. The 'set'
// method may create a new asset by specifying a new key-value pair.
func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response {

}
```