# Build First Network

[](http://hyperledger-fabric.readthedocs.io/en/latest/build_network.html)

`cd fabric-samples/first-network`

* 실행하기

`byfn.sh` 파일을 제공했다. 이 파일은 다른 기관 두 개와 주문자 노드를 나타내는 피어 4개가 있는 Fabric network를 부트한다.
그리고 컨테이너를 실행하고, 안에서 스크립트가 피어들을 채널에 들어오게 하고 체인코드를 배포하고 인스턴스화한다. 그리고 트랜잭션을 배포된 체인코드가 실행시킨다.

채널 이름을 고르지 않으면 기본 값 `mychannel`이 설정된다.

## Generate Network Artifcats

`./byfn.sh -m generate`

```bash
##### Generate certificates using cryptogen tool #########
#########  Generating Orderer Genesis block ##############
### Generating channel configuration transaction 'channel.tx' ###
#######    Generating anchor peer update for Org1MSP   ##########
#######    Generating anchor peer update for Org2MSP   ##########
```

첫 번째 단계로 모든 증명서와 키를 모든 네트워크 개체들을 위해 생성했다.
그리고 `genesis block`이 주문 서비스를 위해 사용되었고, [채널](http://hyperledger-fabric.readthedocs.io/en/latest/glossary.html#channel)을 형성하기 위해 설정 트랜잭션에 사용되었다.

```txt
채널은 사설 블록체인으로, 데이터 고립화와 기밀성을 유지시켜준다.
채널 특정 장부는 채널 안에 있는 피어들 사이에 공유되고, 거래하는 파티들은 거래할 채널에 적절하기 인증해야 한다.
```

## Bring up the Network

Go : `./byfn.sh -m up`
Node : `./byfn.sh -m up -l node`

이 커맨드는 Golang 체인코드 이미지를 컴파일하고 해당하는 컨테이너를 구동한다.
`Go`는 기본 체인코드 언어지만, Node.js 체인코드를 만들 수도 있다.

```bash

 ____    _____      _      ____    _____
/ ___|  |_   _|    / \    |  _ \  |_   _|
\___ \    | |     / _ \   | |_) |   | |
 ___) |   | |    / ___ \  |  _ <    | |
|____/    |_|   /_/   \_\ |_| \_\   |_|

Channel name : mychannel
Creating channel...
```

로그는 여기서부터 시작된다. 컨테이너들을 모두 구동하고, 완전한 엔드-투-엔드 애플리케이션 시나리오를 실행한다. 성공적으로 완료되었다면

```txt
===================== All GOOD, BYFN execution completed =====================


 _____   _   _   ____
| ____| | \ | | |  _ \
|  _|   |  \| | | | | |
| |___  | |\  | | |_| |
|_____| |_| \_| |____/
```

메시지를 출력한다. 스크롤해서 다양한 트랜잭션을 확인할 수 있다.
순서는
    채널을 만든다.
    모든 피어가 채널에 들어오도록 한다.
    [peer0.org1, peer1.org1, peer0.org2, peer1.org2]
    채널에서 Org1MSP, Org2MSP 앵커 피어를 업데이트한다.
    체인코드가 피어들에게 설치된다.
    peer0.org1의 트랜잭션이 성사된다.
    peer1.org2에 대한 쿼리를 진행한다.

## Bring Down the network

`./byfn.sh -m down`

정리를 진행한다.

아래부터는 기본 툴링, 부트스크랩 메커니즘에 대해 설명한다.

## Crypto Generator

`cryptogen`툴은 네트워크의 다양한 개체를 위해 x509 인증서를 만들어낸다.
이 인증서는 id를 나타내며 개태들의 통신/거래 때 서명/검증을 수행할 수 있다.

### 작동방식

```yaml

OrdererOrgs:
  # ---------------------------------------------------------------------------
  # Orderer
  # ---------------------------------------------------------------------------
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
# ---------------------------------------------------------------------------
# "PeerOrgs" - Definition of organizations managing peer nodes
# ---------------------------------------------------------------------------
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    EnableNodeOUs: true

    Template:
      Count: 2
    Users:
      Count: 1
  - Name: Org2
    Domain: org2.example.com
    EnableNodeOUs: true
    Template:
      Count: 2
    Users:
      Count: 1
```

Cryptogen은 `crypto-config.yaml`을 사용한다.
이 설정파일은 네트워크 토폴로지를 포함하고 있어 조직과 조직에 속하는 요소들을 위해 인증서와 키들을 생성할 수 있다.
각 조직은 고유한 루트 인증서(ca-cert)가 제공되어, 동료/주문자 등 특정 요소를 해당 조직에 바인딩한다.
각 조직에 고유 CA 인증서를 할당함으로서, 우리는 참여하는 멤버가 자체 Certificate Authority를 사용하고 있는 전통적인 네트워크를 모방한다.
Fabric에서 작동하는 트랜잭션과 통신은 개인키로 서명되고(`keystore`), 공개키를 사용해 확인한다.(`signcerts`)

파일에는 `count` 변수가 있다. 이 값은 Org에 있는 Peer 수를 정하는 데 쓴다.
툴을 실행하기 전에 `Name`,`Domain`,`OrdererOrgs` 헤더에 있는`Spec` 파라미터를 보자.

각 네트워크 개체에 적용되는 네이밍 컨벤션은 다음과 같다.
"{{.Hostname}}.{{.Domain}}"
그래서 순서 노드를 참조점으로 사용해, `Orderer` MSP ID에 연결된`orderer.example.com` 오더링 노드가 남는다.
이 파일은 상세한 설명이 되어 있다. MSP

`cryptogen` 툴을 사용한 뒤, 생성된 인증서 및 키는 `crypto-config` 폴더에 저장된다.

## Configuration Transaction Generator

`configtxgen` 툴은 네 개의 설정 아티팩트를 만든다.

* orderer `제네시스 블록`

* channel `설정 트랜잭션`

* 두 개의 `anchor peer transaction` (각각의 피어 조직)

더 자세한 설명은 `--help` 명령으로 볼 수 있다.

오더러 블록은 오더링 서비스를 위한 `Genesis Block`이고, 채널 설정 트랜잭션 파일은 채널 생성 시간에 오더러에게 브로드캐스트된다.

### 작동 방식

Configtxgen은 `configtx.yaml` 파일을 사용한다.
이 파일에는 샘플 네트워크의 정의가 포함되어 있다.

```yaml
Profiles:

    TwoOrgsOrdererGenesis:
        Capabilities:
            <<: *ChannelCapabilities
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
            Capabilities:
                <<: *OrdererCapabilities
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
                    - *Org2
    TwoOrgsChannel:
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Org1
                - *Org2
            Capabilities:
                <<: *ApplicationCapabilities

Organizations:
    - &OrdererOrg
        Name: OrdererOrg
        ID: OrdererMSP
        MSPDir: crypto-config/ordererOrganizations/example.com/msp
    - &Org1
        Name: Org1MSP
        ID: Org1MSP
        MSPDir: crypto-config/peerOrganizations/org1.example.com/msp
        AnchorPeers:
            - Host: peer0.org1.example.com
              Port: 7051
    - &Org2
        Name: Org2MSP
        ID: Org2MSP
        MSPDir: crypto-config/peerOrganizations/org2.example.com/msp
        AnchorPeers:
            - Host: peer0.org2.example.com
              Port: 7051
OrdererType: solo

    Addresses:
        - orderer.example.com:7050
    BatchTimeout: 2s
    BatchSize:
        MaxMessageCount: 10
        AbsoluteMaxBytes: 99 MB
        PreferredMaxBytes: 512 KB

    Kafka:
        Brokers:
            - 127.0.0.1:9092
    Organizations:

Application: &ApplicationDefaults
    Organizations:
Capabilities:
    Global: &ChannelCapabilities
        V1_1: true
    Orderer: &OrdererCapabilities
        V1_1: true
    Application: &ApplicationCapabilities
        V1_1: true

```

오더러 조직(OrdererOrg), 두 피어 노드를 관리/유지하는 두 피어 조직(Org1, Org2) 세 멤버가 있다.
이 파일은 두 피어 조직으로 구성된 컨소시엄을 지정하고 있다(`SampleConsortium`)

Profiles 섹션에 주목해보자.

```yaml
Profiles:

    TwoOrgsOrdererGenesis:
        Capabilities:
            <<: *ChannelCapabilities
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
            Capabilities:
                <<: *OrdererCapabilities
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
                    - *Org2
    TwoOrgsChannel:
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Org1
                - *Org2
            Capabilities:
                <<: *ApplicationCapabilities
```

두 개의 고유한 헤더가 있다. 하나는 오더러 제네시스 블록을 위한 `TwoOrgsOrdererGenesis`이고 하나는 우리 채널을 위한 `TwoOrgsChannel`이다.

이 헤더들은 중요하다. 아티팩트를 생성할 때 인자로 전한다.

`SampleConsortium`은 시스템 레벨 프로필에 정의된 뒤 채널 레벨 프로필에서 참조된다. 컨소시엄의 범위 내에 채널이 존재하며, 모든 컨소시엄은 네트워크 범위 전체에 정의되어야 한다.

이 파일은 두 추가적인 정의를 한다.
첫번쨰로, 우리는 각 피어 조직에 대한 앵커 피어를 지정한다.(peer0.org1.example.com, peer0.org2.example.com)
두번째로, 각 멤버에 대한 MSP 디렉터리를 지정해 오더러 제네시스 블록에 차례로 각 조직에 대한 루트 인증서를 저장할 수 있다. 이 개념은 중요하다. 이제 오더링 서비스와 통신하는 모든 네트워크 개체는 자신의 디지털 서명을 인증받을 수 있다.

## 직접 툴 실행하기

cryptogen, configtxgen 커맨드를 이용하거나 `byfn.sh` 스크립트를 적용할 수 있다.

### Manaually generate the artifacts

#### `cryptogen`

```bash
function generateCerts (){
  which cryptogen
  if [ "$?" -ne 0 ]; then
    echo "cryptogen tool not found. exiting"
    exit 1
  fi
  echo
  echo "##########################################################"
  echo "##### Generate certificates using cryptogen tool #########"
  echo "##########################################################"

  if [ -d "crypto-config" ]; then
    rm -Rf crypto-config
  fi
  set -x
  cryptogen generate --config=./crypto-config.yaml
  res=$?
  set +x
  if [ $res -ne 0 ]; then
    echo "Failed to generate certificates..."
    exit 1
  fi
  echo
}
```

`generateCerts` 함수를 살펴보면 인증서 생성에 필수적인 명령을 볼 수 있다.

먼저 `cryptogen` 툴을 실행한다.
`cryptogen generate --config=./crypto-config.yaml`

그러면 MSP 매터리얼(인증서, 키)가 `crypto-config` 디렉터리에 저장된다.

* `configtxgen`

`configtxgen` 툴에 설정 파일 `configtx.yaml`을 찾을 곳을 설정해준다.

`export FABRIC_CFG_PATH=$PWD`

그리고 오더러 제네시스 블록을 생성한다.

`configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block`

## Create a Channel Configuration Transaction

채널 트랜잭션 아티팩트를 만들어야 한다.
`$CHANNEL_NAME`이나 `CHANNEL_NAME` 환경 변수를 설정해 이 명령을 처리할 때 쓰도록 하자.

```bash
# The channel.tx artifact contains the definitions for our sample channel

export CHANNEL_NAME=mychannel  &&configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME
```

이제 조직1에 대한 앵커 피어를 만들 채널에 설정한다. `$CHANNEL_NAME`을 주의한다.

`configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP`

조직2에 대한 앵커 피어도 만든다.

`configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP`

## Start the network

docker-compose 파일은 우리가 이전에 다운받은 이미지를 참조하고 있고, 오더러를 우리가 아까 생성한 `genesis.block`으로 부트스트랩한다.

우리는 이 커맨드를 수동으로 수행해 각 호출의 구문과 기능을 알아본다.

네트워크를 시작한다.

`docker-compose -f docker-compose-cli.yaml up -d`

로그를 보고 싶다면 -d를 쓰지 않는다.
로그 스트림을 하면 새로운 터미널을 열어야 한다.
CLI는 1000초동안 idle상태가 되며, `docker start cli` 명령으로 재시작 할 수 있다.

## Environment variables

`peer0.org1.example.com`에 대한 cli 명령이 작동하도록 하려면, 네 가지 환경 변수를 사용해 명령을 시작해야 한다. `peer0.org1.example.com`에 대한 변수는 cli 컨테이너에 구워져, 그것들을 전달할 필요 없이 작동할수 있다. __하지만__ 다른 피어나 오더러의 콜을 보려면 해당 값을 적절하게 제공해야 한다.
`docker-compose-base.yaml` 파일을 봐 구체적인 경로를 보자.

```bash
# Environment variables for PEER0

CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
CORE_PEER_ADDRESS=peer0.org1.example.com:7051
CORE_PEER_LOCALMSPID="Org1MSP"
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
```

## Create & Join Channel

채널 설정 트랜잭션을 만들었다. `configtx.yaml` 프로필을 이용해 그 과정을 다시 반복하면 채널을 더 만들 수 있다.

도커 컨테이너에 접속한다.

`docker exec -it cli bash`

그리고 채널 설정 트랜잭션 아티팩트를 오더러에게 넘겨 채널 생성 요청을 보내보자.
`-c` 플래그로 채널 이름을 지정하고 `-f` 플래그로 채널 설정 트랜잭션을 지정한다.
`channel.tx`에서는 채널 트랜잭션을 다른 것으로 마운트할 수 있다.
다시 환경변수를 `CHANNEL_NAME`으로 설정해 명시적으로 넘기지 않아도 되게 하자.

```bash
export CHANNEL_NAME=mychannel

# the channel.tx file is mounted in the channel-artifacts directory within your CLI container
# as a result, we pass the full path for the file
# we also pass the path for the orderer ca-cert in order to verify the TLS handshake
# be sure to export or replace the $CHANNEL_NAME variable appropriately

peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
```

--cafile 옵션으로 인증서를 넘겼다. 이것은 오더러의 루트 인증서 패스로, 우리를 TLS 핸드셰이크를 검증하게 해준다.

위 명령어는 `channel-ID.block` 제네시스 블록을 반환해, 채널에 입장할 때 쓰인다.
제네시스 블록은 `channel.tx`에서 설정한 설정 정보가 있다.

채널에 입장한다.

`peer channel join -b mychannel.block`

환경 변수 섹션에서 사용한 네 가지 환경 변수를 변경해 다른 피어들이 필요에 따라 채널에 참가할 수 있도록 할 수 있다.

모든 피어가 들어오는 것보다, `peer0.org2.example.com`을 입장시켜 앵커 피어 정의를 채널에 업데이트시켜보겠다.
기본 환경 변수가 CLI 컨테이너에 오버라이드되어있으므로,
`CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID="Org2MSP" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt;peer channel join -b mychannel.block`

전체 스트링을 한번에 넘기지 않고 환경 변수를 각각 넣을 수 있따.
이 환경변수가 슽뒈면 `peer channel join` 명령을 다시 실행해 CLI 컨테이너가 `peer0.org2.example.com`에서 작동하도록 한다.

## Update the anchor peers

채널 업데이트로, 채널의 정의를 전파하자. 채널의 제네시스 블록 위에 새로운 구성 정보를 생성한다. 제네시스 블록을 수정하는 게 아니라 변경값을 채널에 저장해 앵커 피어를 정의하는 것이다.

```bash
# 조직1의 앵커 피어 정의를 채널에 업데이트하자.
peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

# 조직2의 앵커 피어 정의를 채널에 업데이트하자. 업데이트를 위해 환경변수를 설정한다.
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID="Org2MSP" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt

peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

```

## Install & Instantiate Chaincode

## Query

## Invoke

## Query_2