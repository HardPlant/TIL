#Simple voting contract

contract는 class 개념이라고 생각하면 된다.
Voting contract는 참여자 배열을 초기화하는 생성자를 가지고 있다.
메서드는 두 개이다. 하나는 참여자의 받은 총 투표 수고, 다른 하나는 참여자의 투표 수를 올리는 것이다.

* 생성자는 블록체인에 컨트랙트를 올릴 때 한 번만 실행된다. 블록체인에 올려진 코드는 불변한다. 즉, 컨트랙트를 업데이트해서 올려도 이전 컨트랙트는 블록체인에 데이터들과 함께 그대로 있고, 새 컨트랙트가 컨트랙트의 새 인스턴스를 만들 것이다.


* 다음 코드를 `hello_world_voting` 폴더의 `Voting.sol` 파일에 복사한다.
```js
pragma solidity ^0.4.11;
// We have to specify what version of compiler this code will compile with

contract Voting {
  /* mapping field below is equivalent to an associative array or hash.
  The key of the mapping is candidate name stored as type bytes32 and value is
  an unsigned integer to store the vote count
  */
  
  mapping (bytes32 => uint8) public votesReceived;
  
  /* Solidity doesn't let you pass in an array of strings in the constructor (yet).
  We will use an array of bytes32 instead to store the list of candidates
  */
  
  bytes32[] public candidateList;

  /* This is the constructor which will be called once when you
  deploy the contract to the blockchain. When we deploy the contract,
  we will pass an array of candidates who will be contesting in the election
  */
  function Voting(bytes32[] candidateNames) {
    candidateList = candidateNames;
  }

  // This function returns the total votes a candidate has received so far
  function totalVotesFor(bytes32 candidate) returns (uint8) {
    if (validCandidate(candidate) == false) throw;
    return votesReceived[candidate];
  }

  // This function increments the vote count for the specified candidate. This
  // is equivalent to casting a vote
  function voteForCandidate(bytes32 candidate) {
    if (validCandidate(candidate) == false) throw;
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
  }
}
```

이 파일은 Node 콘솔에서 컴파일할 것이다.
`node` 명령어로 NodeJS 콘솔을 연 뒤에 web3 객체를 만든다.

```js
Web3 = require('web3')
web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"))
```


`testrpc`가 구동되어 있다면, 다음 결과를 얻을 수 있다.
```js
> web3.eth.accounts
[ '0x679275fb1ea211cf1dce9895b0c77f63b93d5e39',
  '0x04fe92b7c7b0632c1d92e3eb5537a63a723b2812',
  '0x36d66de81ce99263ddb15f4d16dd0e4ecf35e990',
  '0x02e21d51433258ff2a8283f5430e6d15b5994dc5',
  '0xac7444307a043612ba226d580370dd14809f024c',
  '0xa2264086a439e4027cc1db4c2d39cc730b3eee81',
  '0xabfb6f1aa35a258d4d2f9b373cbf62941b1a3e07',
  '0xf3633f87f55501e458d65b7b744d1657ce5029d6',
  '0x00dda6118658393e2818831c78dcb39620ea0cea',
  '0x195cc7317169c17b2f7e96fa09da0a8169d29f87' ]
```

컨트랙트를 컴파일하려면, 파일을 읽어서 solc로 컴파일한다.
```
> code = fs.readFileSync('Voting.sol').toString()
> solc = require('solc')
> compiledCode = solc.compile(code)
```

컴파일된 코드의 필드 중에서 두 가지를 알아야 한다.