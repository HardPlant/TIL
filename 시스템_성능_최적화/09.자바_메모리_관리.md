# 자바 메모리 관리

클래스로더는 자바 라이브러리, 클래스 파일과 상호작용하고,
자바 프로세스 메모리는 텍스트, 데이터, 힙, 스택 등 네이티브 메모리 영역과,

네이티브{텍스트, 데이터, 힙, 스택}
클래스로더{자바 라이브러리, 클래스 파일}<->
    JVM 메모리:
        메서드 영역
        자바 힙 객체
        스레드 별로:
            자바 스택{메서드, 파라미터, 로컬 변수}
            자바 PC 레지스터{프로그램 카운터}
실행 엔진<->    <->자바 네이티브 인터페이스 <-> 네이티브 라이브러리
    {컴파일러, 가비지 컬렉터}

로 구성되어 있다.

VM 힙 메모리는 네이티브 힙 영역 중 일부이며,
자바 스택은 네티이브 스택 기반 위에서 구동되며,
VM의 실행 모듈 및 관련 라이브러리는 네이티브 텍스트에 존재한다.
자바 애플리케이션 라이브러리 jar, zip은 네이티브 영역에 Memory Mapped File 형태로 위치한다.

### 가비지 컬렉션

전담 스레드가 실행함

객체가 변수 가시구역(Visible Area)에 벗어나 있고, 참조(Reference)하는 다른 객체가 없어졌을 때 발생한다.
참조하는 객체도 변수 가시구역에 없고, 참조하는 다른 객체가 없으면 GC 대상이 된다.

이런 조건을 찾다 보면 스택 내 로컬 변수, 싱글턴 구조의 정적 변수만 남게 된다.

GC 동안 메모리 체크, 정리하는 작업으로 애플리케이션 동작이 멈추므로, GC 최적화는 중요하다.

### Oracle/HP JVM 힙 메모리 구조

Generation 방식으로 관리함, JDK7 G1(Garbage First) GC 옵션 사용 시 메모리를 Region으로 나눠 개별적 관리함

JVM Heap: -Xms, -Xmx(Old Generation까지)
    Younger Generation: -Xmn -XX:NewSize -XX:MaxNewSize -XX:NewRatio
        Survivor: -XX:SurvivorRatio
            From, to
        Eden
    Old Generation: -XX:MaxTenuringThreshold

    Permanent Generation: -XX:PermSize, -XX:MaxPermSize

* Eden: 클래스 인스턴스 객체가 새로 생성되는 공간
Eden 영역이 다 차면 Yonger GC(Minor GC) 발생

* Survivor: Young GC 발생 시 살아남은 객체가 이동
    Survivor0: Young GC 대상
    Survivor1: Young GC 2번 발생 시 이동, 일정 조건 이상 살아남으면 OldGen

* Old Generation: MaxTenuringThreshold 값이 Minor GC 횟수고, 이 횟수 동안 살아남으면 이동함
생명주기가 긴 객체가 머무름
여기 객체 옮길 공간이 없으면 Full GC가 발생해 생명주기가 끝난 객체 정리함
Full GC 발생 시 Yong, Old, Permanent 모두 GC가 발생함

* Permanent Gen : 클래스로더에 의해 클래스 로드 시 저장
