# SQL 튜닝

통상 서버 처리시간의 70% 이상이 SQL 처리시간임

단순한 쿼리에 적절한 인덱스가 없어 시스템의 전체 성능에 영향을 미침
개발자가 쿼리를 작성하지만 성능 개선은 DB 전문가가 함

단순한 쿼리는 개발자도 튜닝할 수 있는 능력을 갖춰야 함

##### 점검할 항목

* 통계
최적 실행계획이 수립되도록 테이블 통계 정보 존재, 주기적 갱신 여부

* 인덱스
적절한 인덱스를 사용하고 있는가?
전체 탐색하는 테이블이 있는가?
인덱스가 있음에도 사용하지 못하는가?
인덱스 수가 많아 INSERT 처리시간이 오래 걸리는가?

* 조인
처리하는 데이터의 양과 연결 관계에 맞는 조인 방식이 선정됐는가?
조인 관계에서 선행 테이블은 적합한가?

* 테이블
데이터 수정과 삭제로 테이블 조각화가 발생해 재구성할 필요가 있는가?
파티션으로 INSERT 부하를 분산해 성능 개선이 가능한가?

### 기본 지식

데이터베이스는 클라이언트, 엔진, 파일시스템으로 구성됨
엔진 메모리{SQL 실행계획, DB 정보(메타 통계), 복구 로그}
파일시스템{환경설정, 사용자 데이터, 시스템 데이터, 복구 로그}

##### 클라이언트 측 개선 사항

복수 건 레코드를 한번 호출로 집합 처리, 두 개 이상의 쿼리를 한 쿼리로 통합 처리
클라이언트/데이터베이스 엔진 간 호출 건수를 줄여 성능 개선

클라이언트에서 JDBC Statement 캐시, SQL 커서 오픈 상태로 유지 -> 쿼리 소프트 파싱 회피

패치(Fetch) 크기를 증가시켜 데이터베이스 엔진에서 클라이언트로 조회된 데이터 전송 시 한번에 많은 데이터 전송

### 데이터베이스 엔진

엔진 내부에서 락 관리, 트랜잭션 관리가 이루어짐

엔진 메모리에는 다음과 같은 데이터가 있음

* 데이터 캐시 : 조회된 데이터를 캐시함, LRU 사용해 제거

* 실행계획 : SQL이 처음 호출되면 실행계획을 만들고 이후 동일한 실행계획을 재사용함

* DB 정보 : 테이블 구성 정보, 통계를 저장하고 있으면서 SQL 검증

* 복구 로그 : 데이터 변경 전후 내역을 모두 저장

### 파일시스템

데이터베이스 구조에서 가장 느린 부분
데이터베이스 서버와 스토리지 간 채널 증설, SSD 교체 등 많은 노력을 함
SQL이 필요 이상으로 많은 데이터베이스를 파일시스템에서 읽지 않도록 예방

### 블록 단위 처리

블록은 데이터 IO의 최소 단위이고, 8KB~64KB 등 다양하게 구성 가능함
SQL 튜닝의 핵심은 읽는 블록 수를 줄이는 것임

레코드 한 건을 읽을 적정한 블록 수를 찾는 것이 관건임

데이터베이스에서 가장 빠른 액세스는 ROWID로 대상 레코드를 읽는 것

ROWID로 조회한 SELECT문 수행 통계를 보면 읽은 논리 블록 수(Buffer Gets)가 1임
기본 키로 레코드 한 건을 조회하면 기본 키 인덱스 탐색 -> 인덱스에 있는 ROWID로 테이블 블록 읽어 레코드 조회

유일 인덱스를 사용하면 3~5블록이면 레코드 1건을 읽음
B 트리 인덱스는 루트 블록, 브랜치 블록, 리프 블록 3단계를 읽어 3블록이 됨
데이터 건수가 억 단위가 되도 이진 인덱스의 깊이가 4단계를 넘어가지 않음, 레코드까지 읽는 블록 수가 5개를 넘지 않음

3개 테이블 조인, 모두 기본 키를 사용해 레코드 1건을 읽으면 9~15블록을 사용함

한 블록에는 복수 건 레코드 존재, 읽은 인덱스 블록에 여러 건 레코드가 존재하므로 10건을 조회해도 7블록만 읽는 것이 가능함

테이블 2개를 조인해 레코드 10건 조회하는 데 읽는 블록 수가 수천~수만 블럭이 되면 SQL 개선 대상임

### 캐시 IO 대 물리 IO

물리 IO가 자주 발생하는 쿼리를 성능 테스트 시 캐시된 상태여서 개선 대상에서 제외시킬 수 있음

## 성능 개선 대상 식별

SQL 개선 작업을 진행하려면 개선 대상을 선정할 능력이 있어야 함
특정 앱 속도가 느리고 APM이 있다면 대상을 수월하게 선정할 능력이 있어야 함

### SQL 수행 통계

기동 후 처리된 SQL에 대한 수행 통계를 가지고 있음

오라클에는 V$SQL, V#SQLAREA라는 시스템 뷰로 SQL 실행계획이 저장된 공유 풀의 수행 통계를 보여줌

`V$SQL`은 공유 풀의 모든 SQL을 개별 단위로 보여줌
`V$SQLAREA`는 동일한 SQL이 공유 풀에 중복 존재하는 경우 취합해 보여줌

```sql
SELECT ROUND(BUFFER_GETS/EXECUTIONS) AS BUFFER_GETS_PER_EXEC, -- 1회 실행당 읽은 블록 수
    ROUND(ELAPSED_TIME/(EXECUTIONS*1000000),2) AS "ELAPSED_TIME_PER_SEC(Sec)" -- 1회 실행당 처리시간(초단위)
    ROUND((ROWS_PROCESSED/EXECUTIONS)) AS ROWS_PER_EXEC, -- 1회 실행당 처리된 건수
    A.*
FROM (SELECT DECODE(EXECUTIONS,NULL,1,0,1,EXECUTIONS) AS EXECUTIONS, -- 누적 실행 횟수
        BUFFER_GETS, -- 누적 읽은 블록 수
        DISK_READS, -- 누적 디스크 읽는 수
        FETCHES,
        ROWS_PROCESSED,
        CPU_TIME, -- 누적 CPU사용시간 (마이크로초)
        ELAPSED_TIME, -- 누적 SQL 처리시간(마이크로초)
        SQL_TEXT, -- SQL 텍스트(1000바이트)
        SQL_ID,
        ADDRESS,
        HASH_VALUES
    FROM V$SQLAREA
    ORDER BY BUFFER_GETS DESC
    ) A
WHERE ROWNUM < 20
```

시스템 통계 뷰로 읽은 블록 수, CPU 사용량, 처리시간 선정 기준에 따라 최상위 SQL을 선정해 개선 가능성을 검토할 수 있다.

`ORDER BY` 절을 필요에 따라 바꾸자.

`V$SESSION` 실시간 정보만 보여주는데, 지난 특점 세션 상태를 볼 수 있다면 그 떄의 SQL 수행 상태를 확인할 수 있다.
`V$ACTIVE_SESSION_HISTORY` 시스템 뷰를 통해 조회할 수 있다.

