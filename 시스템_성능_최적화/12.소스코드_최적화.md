# 소스코드 최적화

### 체크리스트

##### 불필요한 작업 제거

단순 정보성 로깅을 하는 부분이 있는가?
로깅을 하지 않을 떄 로깅을 위한 문자열이나 데이터가 만들어지고 있는가?
전문 파싱이나 환경설정 로딩과 같은 작업이 반복 수행되는가?

##### 로직 최적화

락 범위를 최소화하거나 락을 회피할 수 있는가?
집합 데이터에 대한 검색 방식은 적절한가?
문자열 처리에 오버헤드가 존재하는가?
반복 처리 로직이 존재하는가?
기능이 단순한 함수이지만 호출 횟수가 많아 성능에 영향을 미치는가?

##### 적극적인 캐시 사용

영업일, 계정과목, 공통코드 같은 소량 테이블에 빈번한 조회가 발생하는가?
배치 같은 경우 결과가 한정적인 데이터에 반복조회가 많이 있는가?
포털 화면에서 보여지는 게시물 목록 같은 것을 캐시할 수 있는가?

##### 효율적인 아키텍처 구성

프로그램 흐름상에 병목이 존재하는가?
대량건 조회는 가능한가?
송수신 전문 포맷과 크기는 시스템 특성과 네트워크 환경에 적합한가?
한 서비스 내에서 연계 시스템과 빈번하게 통신하는가?

### 소스코드 최적화를 수행할 때 검토해야 할 순서

##### 기반 한경

자바 GC와 같은 기반 환경에 의한 영향도 확인, 성능 저하 요소 제거
자바 GC 시간이 전체 응답시간의 50% 이상이라면 수집된 메서드 간 처리시간 비중을 신뢰할 수 없으므로 GC 개선 작업이 먼저 이뤄져야 함

##### 프레임워크

전문 처리, 트랜잭션 관리, SQL 수행, 로깅, 작업 선/후 처리, 분산 처리, 대외 인터페이스 등 애플리케이션 위한 기본 기능 제공

업무 개발자가 작성하는 코드는 프레임워크 기반 위에서 제공되는 API를 사용해 구현되기 때문에 업무 개발자의 코드 비중이 높지 않음
전체 응답시간에서 DB 처리시간을 제외하면 사실상 프레임워크 수행시간이라고 해도 과언이 아님

##### 공통 모듈

고객정보 조회, 조직정보 조회, 공통코드 조회, 영업일 조회 등 애플리케이션 전반에서 공통으로 사용하기 위해 만ㄷ르어 놓은 모듈
최적화 우선순위가 높음
공통 모듈은 다양한 업무의 요구사항을 수용하기 위해 필요 이상으로 많은 데이터 조회, 이에 집중해서 분석

##### 업무 모듈

개별 어플리케이션 개선 사항이 타 애플리케이션에 공통적으로 적용되는 경우 많음, 개선사항을 정리해 주기적으로 개발자 교육


### 불필요한 작업 제거

#### 로깅

성능 영향도 높은, 수정하는 난이도 낮음
전체 응답시간의 50% 이상이 로깅 코드에서 소요될 수도 있음

##### 잘못 사용된 로깅 수준

Log4j : 전체, 추적, 디버그, 정보, 에러, 심각, 끄기 8개 수준

* 운영 시 : 경고, 에러 수준 로깅

* 추적, 디버그, 정보 성격 로그를 에러, 심각으로 남기지 않음

##### 불필요한 메시지 생성

```java
output = outputFilList.getLData(inx); // 객체도 존재함
LLog.debug.println("이 메시지는 디버그 로깅이 사용되지 않아도 수행됨" + object); // String+object.toString()이 항상 실행됨
if(LLog.debug.isEnabled()){ /*이런 식으로 감싸줘야 함*/}
```

##### 효율적인 로깅 개선

로그를 전체 환경설정 정보보다는 요청에 대한 스레드 컨텍스트 단위로 하도록 개선

서비스 호출 단위로 로그 수준을 설정할 수 있게 하면 됨

##### 트랜잭션 저널 로그

금융권, 로그 기반 통계분석 수행 시스템에서 서비스 요청/응답에 대해 통신 전문, 처리 정보를 로그로 남기는 트랜잭션 저널 로그가 중요한 부분으로, DB에 로그를 저장함
TPS가 높으면 트랜잭션 저널 로그를 DB에 입력할 때 병목이 발생함

개선방안으로 보통 다음을 생각할 수 있음

* 해시 파티션

DB 테이블을 해시 파티션으로 구성, 입력 부하를 파티션에 균등 분할함

* 비동기 처리

저널 로그는 통계용으로 바로 사용되지 않으므로, 온라인 서비스에서 큐나 파일에 저장 후 이후 별도의 스레드나 프로세스로 대량으로 DB 입력 처리

* 비핵심업무 제외

모든 서비스에 대해 저널 로깅을 실시하는 대신 핵심 업무에 대해 로깅 실시

* 저장 데이터 최소화

저널 로그 저장 시 전체 전문 대신 응답 메시지는 전문 헤더만 남기거나 응답 전문을 저장 대상에서 제외

* 내부 연계 제외

외부 인터페이스만 로깅

###### 사례

* 현상

온라인 서비스가 하루에 한 번씩 맘춰 WAS를 재기동해야 했음

* 접근 방법

자바 스택을 수집해 평상시 성능 분석 결과, 전체 서비스 시간에서 60% 이상이 로깅에서 소요되고 있었음
로깅 파일시스템은 NFS이고, WAS 서버 2대가 모두 동일한 파일에 로깅을 남겨 사용자가 증가했을 때 로깅에 미치는 영향이 큼
추가 변석 결과 JSP 변경 여부 확인 주기가 짧음

* 원인

평상시 5회 스레드 덤프 수집 분석, 180개 스레드가 사용자 요청 처리 중, 123개 스레드가 로깅 관련 작업 중이었음. WAS 처리시간 중 2/3이 로깅에 소요

120개 스레드 풀 중 98개가 작업 중일 때 스레드 덤프 분석 결과, 로깅에 58개, JSP 체크에 34개, 파일 전송에 1개, DB 조회에 2개, 화면 응답 전송에 2개를 사용하는 것으로 밝혀짐

로그 파일은 NFS로 2대 WAS가 동일한 파일에 기록, 로그를 순차적으로 기록해야 하므로 성능 저하 유발

JSP 변경 여부 확인 주기가 웹로직 기본값인 1초로 설정, 너무 빈번하게 확인됨

* 조치

DB SQL 수행 로그를 남기지 않게 함, 디버그 로깅 수준을 경고로 변경
NFS 상에서 한 개 파일로 로깅하는 것을 WAS 인스턴스 별로 로깅하도록 변경
로깅 코드 중 불필요하게 로깅을 많이 남기는 상위 12개 소스 선정해 수정
(정보성 로깅, 통신 단절(Broken pipe)같은 빈번한 예외 발ㄹ생 시 예외 스택 대신 에러 메시지 1줄 기록)
JSP 확인 주기를 1초에서 60초로 변경
(WEB-INF/weblogic.xml 파일의 jsp-descriptor 아래에 pageCheckSeconds 파라미터 수정)

* 결과

2일간 추가 모니터링 기간 시 성능 저하가 발생하지 않음

#### 불필요한 로직

공통 모듈을 사용할 때 주로 나타남
애플리케이션에서 고객번호 토대로 고객정보 읽어오는 공통 모듈
-> 애플리케이션에서 고객명만 사용하지만 주민등록번호 등 암호화된 것들도 불러오게 됨, 많은 CPU 자원 낭비

포괄적인 정보 외 사용 패턴 고려해 세분화된 정보 제공하는 함수도 제공해야 함

###### 로깅 시 불필요한 로직에 의한 성능 저하 사례

* 현상

필요에 의해 업무 처리 로그를 많이 남기는 시스템에서 성능 저하 발생

* 원인

로그를 처리하는 로직이 비효율적으로 불필요한 기능을 많이 수행

수행 단계 :
    1 현재 시간 정보 조회
    2 로그 포맷 구성
    3 로그 디렉터리명 구성
    4 로그 디렉터리 존재 여부 확인
    5 파일명 구성
    6 파일 존재 여부 확인
    7 파일 존재 시 추가 모드, 없으면 생성
    8 로그 쓰기
    9 파일 닫기
    10 보관 기간이 지난 로그 파일명 구성
    11 보관 기간이 지난 파일 존재 확인
    12 보관 기간이 지난 파일 삭제

* 조치

로그 파일은 하루 단위로 프로세스당 하나씩 사용하므로, 로그를 쓸 때마다 열고 닫는 작업을 하루 1회로 변경
로그를 쓸 때 불필요한 기능은 하루에 한번 이뤄지는 파일 열기/닫기 시 함께 수행

그래서 로그 처리가 두 단위로 나눠짐, 빈번하게 발생하는 로그 기록은 4단계로 단순화됨

* 하루 1회 수행 : 초기 수행, 날짜 변경 시

    1 열린 로그 파일이 있으면 닫기
    2 현재 시간 정보 조회
    3 로그 디렉터리명 구성
    4 로그 디렉터리 존재 여부 확인
    5 파일명 구성
    6 파일 존재 여부 확인
    7 파일이 존재하면 추가 모드로 열고, 없으면 생성
    8 보관 기간이 지난 로그 파일명 구성
    9 보관 기간이 경과한 파일 존재 확인
    10 보관 기간이 경과한 파일 삭제

* 로그 기록 시

    1 현재 시간 정보 조회
    2 날짜 변경 여부 확인 (변경 시 위 프로세스 수행)
    3 로그 포맷 구성
    4 로그 쓰기

#### 반복 로직

동일하게 반복 수행하는 로직
재사용할 수 있게 변수나 캐시를 두면 됨

* 통신전문에서 동일한 항목을 읽을 시 파싱 작업 (전체 처리시간의 80%가 소모될 수도 있음)

통신전문 객체 내부에 자징영 객체를 둬서 파싱된 항목은 저장해 두고 재사용

* for, while 문 안에서 동일한 값으로 동일한 계산식 수행

루프 밖에서 사전에 계산해 변수로 저장
호출 빈도가 엄청날 시 개선 사항에 포함

* 외부 인터페이스 호출할 때마다 관련 환경설정 파일을 매번 읽어들임

싱글턴 기반의 환경설정 저장 객체 생성

### 로직 최적화

#### 락 최적화

C/C++ : 세마포어, 뮤텍스, 크리티컬 섹션
Java : synchronized, wait/notify, java.util.concurrent

##### 락 범위 최소화

애플리케이션 설계할 시 락으로 보호하는 코드의 범위를 줄일 수 있음

* 락 세분화

캐시를 구성할 때 데이터 종류별로 하나의 메모리 구조로 설계하는 것이 일반적임, 동시 대량 처리 시 락 경합이 발생할 수 있으므로 복수 개 메모리 구조로 쪼갬
예를 들어 String의 경우 분포도 좋은 시작/끝 한 문자를 사용해 5개 그룹으로 분류해 5개 캐시 구성

메서드 전체에 synchronized 대신 락이 필요한 공통 부분에만 synchronized를 여러 개 쓰는게 나을 수 있음

* 락 범위 최소화

개발자가 사용하는 메서드 안의 synchronized가 있을 수 있음, StringBuilder 등으로 로그 문자열을 만든 뒤 synchronized를 시작하는 것이 나음

##### 락 제거

환경설정 새로 읽거나 캐시 재로딩 시, 타 스레드가 다시 이 작업을 실행하지 않고 기존 데이터를 참조할 수 있도록

예를 들어 StringBuffer의 경우 여러 스레드가 동시에 데이터를 수정하지 않는 StringBuilder로 바꾸는 게 나음
StringBuffer는 스레드 안전하게 synchronized 처리가 있음

### 문자열 처리 개선

서비스 응답시간 대비 문자열 처리가 오래 걸리는 경우는 거의 없지만, 문자열 관련 메서드를 많이 호출하거나 배치에서 대량 데이터를 처리하는 경우 문자열 처리가 전체 처리시간 대비 높은 비중을 보일 수 있다.
CPU 사용량이 높아 조금이라도 낮춰야 할 경우에도 문자열 처리르 ㄹ개선하기도 한다.
자바 String 객체의 format, replaceAll 메서드 등을 사용하지 않고 직접 구현해 오버헤드를 줄이는 경우가 간혹 있다.

##### String,format 메서드

100,000회 시도 시...

```java
String.format("%s %s", "Al", "45"); // 540ms 소요
new StringBuilder(50).append("Al").append(" ").append(45).toString(); // 50ms 소요
```

##### String.replaceAll 메서드

100,000회 시도 시

```java
result=source.replaceAll("test re[;ace test replace","replace", "______") // 328ms
result=replace("test re[;ace test replace","replace", "______") // 63ms
```

직접 구현한 replace 메서드

```java
static private String replace(String source, String target, String replace){
    int stt = 0;
    int inx = source.indexOf(target);
    if(inx < 0) return source;

    int length = target.length();
    StringBuilder buffer = new StringBuilder(source.length()*2);
    while(inx >= 0){
        buffer.append(source.substring(stt, ind)).append(replace);
        stt = inx + length;
        inx = source.indexOf(target, stt);
    }
    if(stt < source.length()){
        buffer.append(source.subbstring(stt));
    }
    return buffer.toString();
}
```

##### 문자열 합치기

"String"+변수+"String" 식으로 처리하면 합치는 횟수만큼 객체가 생성됨
현재는 StringBuilder()로 처리하므로 개선하지 않아도 됨

##### 리플렉션 호출 제거

프로그램에 유연성, 확장성을 제공하지만 객체 생성, 메서드 호출 준비 작업 하나하나가 메서드 호출하는 것과 맞먹는 비용 듬

1000000회 시도 시..

```java
Class cls = Class.forName("invoke.target"); // 소요시간 2754ms
Class partypes[] = new Class[1];
partypes[0] = Interger.TYPE;
Method meth = cls.getMethod("getValue1", partypes);
Object metobj = cls.newInstance();
Object arglist[] = new Object[1];
arglist[0] = new Integer(i);
retInt = (Integer)meth.invoke(methobj, arglist);

Target target = new Target(); //소요시간 16ms
retInt = target.getValue1(i);
```

스프링 프레임워크 AOP를 이용해 공통 메서드 수만번 호출 시 전체 응답시간의 10% 이상이 리플렉션 처리에서 소요되는 경우도 있었음

상품별 계산식을 클래스로 구현하고 Method.invoke() 메서드로 유연하게 대응할 수 있는 경우가 있었는데, 전체 응답시간 40%가 invoke 준비에 서요되서 현재 존재하는 상품 유형에 대해 직접 호출하게 만들어 응답시간 40%를 제거한 사례도 있음

##### 채번

DB 기본 키를 구성하기 위해 채번하는 경우가 있는데, 애플리케이션 코드 대신 DB 내부에서 채번하는 경우가 있음

* 기본 최댓값 조회 
`SELECT MAX+1 FROM 테이블 WHERE ...`

동시 채번 이뤄질 경우 후속 작업 에러 발생 가능함
채번 시 사용자, 계좌별로 채번되어 동일 번호 채번 가능성이 없을 때 적용

* 채번 테이블
```sql
SELECT NUM+1 FROM 채번 태이블 WHERE TYPE = :유형 FOR UPDATE
...
UPDATE 채번 테이블
SET NUM+1
WHERE TYPE=유형
```
채벌 테이블에 유형별 레코드로 채번 번호 관리
동시 채번 문제 해결 위해 `SELECT FOR UPDATE` 구문 사용
레코드 락 점유시간 최소화 위해 트랜잭션 처리 필요, 채번 요청 많을 시 단일 병목지점

* DB 채번 기능

`SEQUENCE`
성능상 우수함, 하지만 성능 저하 발생 시 캐시해서 사용하는 추가 기능 고려

DB를 사용하지 않는 것이 가장 좋음
유일한 숫자 필요 시 WAS 인스턴스, 서버 고유번호, 시스템 시간, 순차번호 등 조합해 GID를 생성하듯이 만들어 사용 가능

애플리케이션 캐시를 사용할 수도 있음

```java
public class SequenceCache{
    static long maxSequence = 0L;
    static long currentSequence = 0L;
    static synchronized public clong getSequence(){
        long sequence = 0L;
        if(currentSquence < maxSequence){
            sequence = currentSequence;
        } else { // 캐시 currentSequence 소진 시 DB에서 채번
            sequence = currentSequence = getDBSequence();
            maxSequence = currentSequence + 10000;
        }
        currentSequence++;
        return sequence;
    }
    static private long getDBSequence(){
        return (채번 테이블 채번..)
        /*
        SELECT NUM+1 INTO 채번
        FROM 채번 테이블
        WHERE TYPE=유형
        FOR UPDATE:
        UPDATE 채번 테이블
        SET NUM + 10000
        WHERE TYPE=:유형
        COMMIT;
        */
    }
}
```

15개 작업 스레드를 가진 10개 자바 프로세스가 병렬적으로 실행되면서 채번 테이블 방식을 사용하는 배치가 있었음
전체 배치 수행시간 대비 채번에 소요된 시간이 59%나 되서, 위 방식으로 사용 시 10000개 단위로 DB 채번 한 번만 수행해 채번 소요 시간이 0.% 수준으로 감소

성능 개선을 위해서는 DB와 애플리케이션 간 호출 횟수를 줄이는 것이 중요함
애플리케이션이 채번 숫자를 알아야 하지 않으면 INSERT, UPDATE SQL에 SEQUENCE.NEXTVAL을 함께 사용함

채번된 숫자를 알려면

```sql
SELECT DB_SEQUENCE.NEXTVAL AS SEQVAL
FROM DUAL CONNECT BY LEVEL <= :cacheSize
```
형식의 SQL을 사용하면 됨
